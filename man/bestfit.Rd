% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bestfit.R
\name{bestfit}
\alias{bestfit}
\alias{bestfit.default}
\alias{bestfit.formula}
\title{Best fit models}
\usage{
bestfit(X, ...)

\method{bestfit}{default}(X, y, t = list(), p = list(), response, ...)

\method{bestfit}{formula}(formula, data, subset, transf = c("rsqrt", "log",
  "sqrt"), ...)
}
\arguments{
\item{X}{a design matrix for a regression model}

\item{\dots}{not used}

\item{y}{the vector of the response variable}

\item{t}{The transformed data}

\item{p}{The combinations of transformed variables to be tested}

\item{response}{The name of the response variable}

\item{formula}{A standard linear regression formula, with no transformation
in the parameters.}

\item{data}{A data frame containing the variables in the model.}

\item{subset}{a specification of the rows to be used: defaults to all rows.
This can be any valid indexing vector (see \link{[.data.frame}) for the
rows of data or if that is not supplied, a data frame made up of the
variables used in \code{formula}.}

\item{transf}{A family of functions to be used to transform the variables in
the data frame, in order to find the best combination of transformation to
be applied to the data - usually functions of the box-cox family.}
}
\value{
a vector with adjusted R2 to each fit
}
\description{
Find best transformations of the parameters for Linear Regression.
}
\details{
\code{bestfit} is a generic function for finding best transformations of the
parameters for Linear Regression.
}
\examples{
best_fit <- bestfit(valor ~ ., data = centro_2015@data)
print(best_fit, n = 20)
s <- summary(best_fit)

#There still may be outliers:
out <- car::outlierTest(s$fit)
outliers <- match(names(out$p), rownames(centro_2015))

# There are two ways to handle with them:

# Recalling bestfit via update with a subset argument ...
best_fit <- update(best_fit, subset = -outliers)

# Or assigning a subset argument directly into summary.bestfit
 s <- summary(best_fit, fit = 1, subset = -outliers)

# The latter takes less computational effort, since it only updates the
#\\code{lm} call of the chosen fit. The former is more precise, since it runs
#\\code{bestfit} again without the outliers.

}
